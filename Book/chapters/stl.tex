% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the course
%%%% Introduction to Scientific Programming in C++/Fortran2003
%%%% copyright 2017 Victor Eijkhout eijkhout@tacc.utexas.edu
%%%%
%%%% stl.tex : about the standard template library
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The C++ language has a \indexterm{Standard Template Library} (STL),
which contains functionality that is considered standard, but that is
actualy implemented in terms of already existing language
mechanisms. The STL is enormous, so we just highlight a couple of
parts.

You have already seen
\begin{itemize}
\item
  arrays (chapter~\ref{ch:array}),
\item strings (chapter~\ref{ch:string}),
\item streams (chapter~\ref{ch:io}).
\end{itemize}

Using a template class typically involves
\begin{verbatim}
#include <something>
using std::function;
\end{verbatim}
see section~\ref{sec:usename}.

\Level 0 {Complex numbers}
\label{sec:stl-complex}

\emph{Complex numbers}\index{complex numbers|textbf} use templating to
set their precision.
\begin{verbatim}
#include <complex>
complex<float> f;
f.re = 1.; f.im = 2.;

complex<double> d(1.,3.);
\end{verbatim}
Math operator like \n{+,*} are defined, as are math functions.

\Level 0 {Containers}

Vectors (section~\ref{sec:stdvector}) and strings
(chapter~\ref{ch:string}) are special cases of a STL
\indextermdef{container}. Methods such as \n{push_back} and \n{insert}
apply to all containers.

\Level 1 {Maps: associative arrays}

Arrays use an integer-valued index. Sometimes you may wish to use an
index that is not ordered, or for which the ordering is not relevant.
A~common example is looking up information by string, such as finding
the age of a person, given their name. This is sometimes called
`indexing by content', and the data structure that supports this is
formally known as an \indextermsub{associative}{array}.

In C++ this is implemented through a \indextermttdef{map}:
\begin{verbatim}
#include <map>
using std::map;
map<string,int> age;
\end{verbatim}
is set of
pairs where the first item (which is used for indexing) is of type
\n{string}, and the second item (which is found) is of type \n{int}.

A map is made by inserting the elements one-by-one:
\begin{verbatim}
#include <map>
using std::make_pair;
age.insert(make_pair("Alice",29));
age["Bob"] = 32;
\end{verbatim}

You can range over a map:
\begin{verbatim}
for ( auto person : age )
  cout << person.first << " has age " << person.second << endl;
\end{verbatim}

\Level 1 {Iterators}

The container class has a subclass \indextermdef{iterator} that can be
used to iterate through all elements of a container. This was
discussed in section~\ref{sec:iterator}.

\Level 0 {Tuples}
\label{sec:tuple}

Remember how in section~\ref{sec:pass-by-ref} we said that if you
wanted to return more than one value, you could not do that through a
return value, and had to use an \indextermsub{output}{parameter}?
Well, using the \ac{STL} there is a different solution.

You can make a \indextermdef{tuple}: an entity that comprises several
components, possibly of different type, and which unlike a
\indextermtt{struct} you do not need to define beforehand.

\lstset{style=reviewcode,language=C++}
\begin{block}{C++11 style tuples}
  \label{sl:tuple11}
  \begin{lstlisting}
    std::tuple<int,double> id = std:
    id = std::make_tuple<int,double>(3,5.12);
    std::get<0>(id) += 1;
  \end{lstlisting}
\end{block}

This does not look terribly elegant. Fortunately,
\emph{C++17}\index{C++!C++17} can use denotations and the \n{auto}
keyword to make this considerably shorter. Consider the case of a
function that returns a tuple. You could use \n{auto} to deduce the
return type:
%
\verbatimsnippet{tuplemake}
%
but more interestingly, you can use a
\indextermbus{tuple}{denotation}:
%
\verbatimsnippet{tupledenote}

\begin{slide}{Function returning tuple}
  \label{sl:tuplefun}
  \begin{multicols}{2}
    \verbatimsnippet{tuplemake}\columnbreak
    \verbatimsnippet{tupledenote}
  \end{multicols}
\end{slide}

\begin{block}{Catching a returned tuple}
  \label{sl:catch-tuple}
  The calling code is particularly elegant:
  %
  \snippetwithoutput{tupleauto}{stl}{tuple}
\end{block}

\Level 0 {Random numbers}

\Level 0 {Time}

