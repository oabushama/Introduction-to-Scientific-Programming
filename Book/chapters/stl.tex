% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the course
%%%% Introduction to Scientific Programming in C++/Fortran2003
%%%% copyright 2017-9 Victor Eijkhout eijkhout@tacc.utexas.edu
%%%%
%%%% stl.tex : about the standard template library
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The C++ language has a \indexterm{Standard Template Library} (STL),
which contains functionality that is considered standard, but that is
actualy implemented in terms of already existing language
mechanisms. The STL is enormous, so we just highlight a couple of
parts.

You have already seen
\begin{itemize}
\item
  arrays (chapter~\ref{ch:array}),
\item strings (chapter~\ref{ch:string}),
\item streams (chapter~\ref{ch:io}).
\end{itemize}

Using a template class typically involves
\begin{verbatim}
#include <something>
using std::function;
\end{verbatim}
see section~\ref{sec:usename}.

\Level 0 {Complex numbers}
\label{sec:stl-complex}

\emph{Complex numbers}\index{complex numbers|textbf} use templating to
set their precision.
\begin{verbatim}
#include <complex>
complex<float> f;
f.re = 1.; f.im = 2.;

complex<double> d(1.,3.);
\end{verbatim}
Math operator like \n{+,*} are defined, as are math functions.

\Level 0 {Containers}

Vectors (section~\ref{sec:stdvector}) and strings
(chapter~\ref{ch:string}) are special cases of a STL
\indextermdef{container}. Methods such as \n{push_back} and \n{insert}
apply to all containers.

\Level 1 {Maps: associative arrays}

Arrays use an integer-valued index. Sometimes you may wish to use an
index that is not ordered, or for which the ordering is not relevant.
A~common example is looking up information by string, such as finding
the age of a person, given their name. This is sometimes called
`indexing by content', and the data structure that supports this is
formally known as an \indextermsub{associative}{array}.

In C++ this is implemented through a \indextermttdef{map}:
\begin{verbatim}
#include <map>
using std::map;
map<string,int> age;
\end{verbatim}
is set of
pairs where the first item (which is used for indexing) is of type
\n{string}, and the second item (which is found) is of type \n{int}.

A map is made by inserting the elements one-by-one:
\begin{verbatim}
#include <map>
using std::make_pair;
age.insert(make_pair("Alice",29));
age["Bob"] = 32;
\end{verbatim}

You can range over a map:
\begin{verbatim}
for ( auto person : age )
  cout << person.first << " has age " << person.second << endl;
\end{verbatim}

\Level 1 {Iterators}

The container class has a subclass \indextermdef{iterator} that can be
used to iterate through all elements of a container. This was
discussed in section~\ref{sec:iterator}.

\Level 0 {Tuples}
\label{sec:tuple}

Remember how in section~\ref{sec:pass-by-ref} we said that if you
wanted to return more than one value, you could not do that through a
return value, and had to use an \indextermsub{output}{parameter}?
Well, using the \ac{STL} there is a different solution.

You can make a \indextermdef{tuple}: an entity that comprises several
components, possibly of different type, and which unlike a
\indextermtt{struct} you do not need to define beforehand.

\lstset{style=reviewcode,language=C++}
\begin{block}{C++11 style tuples}
  \label{sl:tuple11}
  \begin{lstlisting}
    std::tuple<int,double> id = std:
    id = std::make_tuple<int,double>(3,5.12);
    std::get<0>(id) += 1;
  \end{lstlisting}
\end{block}

This does not look terribly elegant. Fortunately,
\emph{C++17}\index{C++!C++17} can use denotations and the \n{auto}
keyword to make this considerably shorter. Consider the case of a
function that returns a tuple. You could use \n{auto} to deduce the
return type:
%
\verbatimsnippet{tuplemake}
%
but more interestingly, you can use a
\indextermbus{tuple}{denotation}:
%
\verbatimsnippet{tupledenote}

\begin{slide}{Function returning tuple}
  \label{sl:tuplefun}
  \begin{multicols}{2}
    \verbatimsnippet{tuplemake}\columnbreak
    \verbatimsnippet{tupledenote}
  \end{multicols}
\end{slide}

\begin{block}{Catching a returned tuple}
  \label{sl:catch-tuple}
  The calling code is particularly elegant:
  %
  \snippetwithoutput{tupleauto}{stl}{tuple}
\end{block}

\Level 0 {Limits}

There used to be a header file \indextermtt{limits.h} that contained
macros such as \indextermtt{MAX_INT}. While this is still available,
the \ac{STL} offers a better solution.

\begin{block}{Templated functions for limits}
  \label{sl:stl-limits}
  Use header file \indextermtt{limits}:
\begin{verbatim}
#include <limits>
using std::numeric_limits;

cout << numeric_limits<long>::max();
\end{verbatim}
\end{block}

\begin{exercise}
  \label{ex:big-factorial}
  Write a program to discover what the maximal~$n$ is so that~$n!$,
  that is, $n$-factorial, can be represented in an \n{int}, \n{long},
  or \n{long long}. Can you write this as a templated function?
\end{exercise}

\begin{block}{Detection of Inf and NaN}
  The functions \indextermtt{isinf} and \indextermtt{isnan} are
  defined for the floating point types (\n{float}, \n{double}, \n{long
    double}), returning a \n{bool}.
\begin{verbatim}
#include <math.h>
isnan(-1.0/0.0);   // false
isnan(sqrt(-1.0)); // true
isinf(-1.0/0.0);   // true
isinf(sqrt(-1.0)); // false
\end{verbatim}
\end{block}

\Level 0 {Random numbers}
\label{sec:stl:random}

The \ac{STL} has a
\indextermbus{random number}{generator}
that is more general and more flexible than the C~version (section~\ref{sec:crand}).
\begin{itemize}
\item There are several generators that give uniformly distributed
  numbers;
\item then there are distributions that translate this to non-uniform
  or discrete distributions.
\end{itemize}

\begin{block}{Random number example}
  \label{sl:stl:rand16}
\begin{verbatim}
// set the default generator
std::default_random_engine generator;

// distribution: ints 1..6
std::uniform_int_distribution<int> distribution(1,6);

// apply distribution to generator:
int dice_roll = distribution(generator);
  // generates number in the range 1..6 
\end{verbatim}
\end{block}

\Level 0 {Time}

