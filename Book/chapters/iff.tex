% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the course
%%%% Introduction to Scientific Programming in C++/Fortran2003
%%%% copyright 2017-9 Victor Eijkhout eijkhout@tacc.utexas.edu
%%%%
%%%% iff.tex : conditionals in Fortran
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Level 0 {Forms of the conditional statement}
\label{sec:iff}

The Fortran conditional statement uses the \indextermfort{if} keyword:

\begin{block}{Conditionals}
  \label{sl:fconditional}
Single line conditional:
\begin{lstlisting}
if ( test ) statement
\end{lstlisting}
The full if-statement is:
\begin{lstlisting}
if ( something ) then
  !! something_doing
else
  !! otherwise_else
end if
\end{lstlisting}
The `else' part is optional; you can nest conditionals.
\end{block}

You can label conditionals, which is good for readability but adds no functionality:
\begin{lstlisting}
checkx: if ( ... some test on x ... ) then
checky:   if ( ... some test on y ... ) then
               ... code ...
          end if checky
        else checkx
             ... code ...
        end if checkx   
\end{lstlisting}

\Level 0 {Operators}

\begin{block}{Comparison and logical operators}
  \label{sl:foperators}
  \begin{tabular}{|l|l|l|l|}
    \hline
    Operator&old style&meaning&example\\ \hline
    \texttt{==}&\indextermfort{.eq.}&equals&\texttt{x==y-1}\\
    \texttt{/=}&\indextermfort{.ne.}&not equals&\texttt{x*x*!=5}\\
    \texttt{>} &\indextermfort{.gt.}&greater&\texttt{y>x-1}\\
    \texttt{>=}&\indextermfort{.ge.}&greater or equal&\texttt{sqrt(y)>=7}\\
    \texttt{<} &\indextermfort{.lt.}&less than\\
    \texttt{<=}&\indextermfort{.le.}&less equal&\texttt{}\\
    &\indextermfort{.and.} \indextermfort{.or.}&and, or&\n{x<1 .and. x>0}\\
    &\texttt{.not.}&not&\n{.not.( x>1 .and. x<2 )}\\
    &\texttt{.eqv.}&equiv&$ (x\wedge y)\vee (\neg x\wedge \neg y)$\\
    &\texttt{.neqv.}&not equiv&$ (x\wedge \neg y)\vee (\neg x\wedge  y)$\\
    \hline
  \end{tabular}
\end{block}

The logical operators such as \indextermfort{.AND.} are not short-cut as
in~C++. Clauses can be evaluated in any order.

\begin{exercise}
  \label{ex:fgrades}
  Read in three grades: Algebra, Biology, Chemistry, each on a scale
  $1\cdots 10$. Compute the average grade, with the conditions:
  \begin{itemize}
  \item Algebra is always included.
  \item Biology is only included if it increases the average.
  \item Chemistry is only included if it is 6~or more.
  \end{itemize}
\end{exercise}

\Level 0 {Select statement}

The Fortran equivalent of the C++ \indextermfort{case} statement is \indextermfort{select}. It takes
single values or ranges; works for integers and characters.

\begin{block}{Select statement}
  \label{sl:fswitch}
  Test single values or ranges, integers or characters:
  %
  \verbatimsnippet{casef}
  %
  Compiler does checking on overlapping cases!
\end{block}

\Level 0 {Boolean variables}

The Fortran type for booleans is \indextermfort{Logical}.

The two literals are \indextermfort{.true.} and \indextermfort{.false.}

\begin{exercise}
  \label{ex:fprintbool}
  Print a boolean variable. What does the output look like in the true
  and false case?
\end{exercise}

\Level 0 {Review questions}

\begin{exercise}
  \label{ex:select-vs-switch}
  What is a conceptual difference between the C++ \n{switch} and the
  Fortran \indextermfort{Select} statement?
\end{exercise}
