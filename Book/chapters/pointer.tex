% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the course
%%%% Introduction to Scientific Programming in C++/Fortran2003
%%%% copyright 2017/8 Victor Eijkhout eijkhout@tacc.utexas.edu
%%%%
%%%% pointer.tex : about pointers
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Level 0 {What is a pointer}

The term pointer is used to denote a reference to a quantity.
There is less need for pointers in C++ than there was in~C.

\begin{itemize}
\item To pass an argument
  \emph{by reference}\index{parameter!passing!by reference},
  use a \emph{reference}\index{reference!argument}.
  Section~\ref{sec:passing}.
\item Strings are done through \n{std::string}, not character arrays;
  see above.
\item Arrays can largely be done through \n{std::vector}, rather than
  \indextermtt{malloc}; see above.
\item Traversing arrays and vectors can be done with ranges;
  section~\ref{sec:arrayrange}.
\item Anything that obeys a scope should be created through a
  \indexterm{constructor}, rather than using \indextermtt{malloc}.
\end{itemize}

Legitimate needs:
\begin{itemize}
\item Objects on the heap. Use \indextermtt{shared_ptr} or
  \indextermtt{unique_ptr}; section~\ref{sec:shared_ptr}.
\item Use \indextermtt{nullptr} as a signal.
\end{itemize}

\begin{block}{Shared pointers}
  \label{sl:shared-ptr}
Shared pointers look like regular pointers:
\begin{verbatim}
#include <memory>

std::shared_ptr<myobject> obj_ptr
    = std::make_shared<myobject>(x);
    // = std::shared_ptr<myobject>( new myobject(x) );
obj_ptr->mymethod(1.1);
cout << obj_ptr->member << endl;

auto array = std::shared_ptr<double>( new double[100] );
// ILLEGAL: array[1] = 2.14;
array->at(2) = 3.15;
\end{verbatim}
\end{block}

\begin{block}{Reference counting illustrated}
  \label{sl:construct-destruct-trace}
  We need a class with constructor and destructor tracing:
  \verbatimsnippet{thingcall}
\end{block}

\begin{block}{Pointer overwrite}
  \label{sl:shared-ptr-overwrite}
  Let's create a pointer and overwrite it:
  %
  \snippetwithoutput{shareptr1}{pointer}{ptr1}
\end{block}

\begin{block}{Pointer copy}
  \label{sl:shared-ptr-copy}
  \snippetwithoutput{shareptr2}{pointer}{ptr2}
\end{block}

\begin{block}{Linked list code}\par 
  \label{sl:share-ptr-node}
\begin{verbatim}
node *node::prepend_or_append(node *other) {
  if (other->value>this->value) {
    this->tail = other;
    return this;
  } else {
    other->tail = this;
    return other;
  }
};
\end{verbatim}
Can we do this with shared pointers?
\end{block}

\begin{block}{A problem with shared pointers}
  \label{sl:share-ptr-node-sh}
\begin{verbatim}
shared_pointer<node> node:prepend_or_append
    ( shared_ptr<node> other ) {
  if (other->value>this->value) {
    this->tail = other;
\end{verbatim}
So far so good. However, \n{this} is a \n{node*}, not a
\n{shared_ptr<node>}, so
\begin{verbatim}
    return this;
\end{verbatim}
returns the wrong type.
\end{block}

\begin{block}{Solution: shared from this}
  \label{sl:share-ptr-node-from}
  It is possible to have a `shared pointer to this' if you
  define your node class with (warning, major magic alert):
\begin{verbatim}
class node : public enable_shared_from_this<node> {
\end{verbatim}
This allows you to write:
\begin{verbatim}
    return this->shared_from_this();
\end{verbatim}
\end{block}
