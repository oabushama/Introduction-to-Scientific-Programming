% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the course
%%%% Introduction to Scientific Programming in C++/Fortran2003
%%%% copyright 2017-9 Victor Eijkhout eijkhout@tacc.utexas.edu
%%%%
%%%% elements.tex : basic language elements
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Level 0 {From the ground up: Compiling C++}

In this chapter and the next you are going to learn the C++
language. But first we need some externalia: how do you deal with any
program?

\begin{block}{Two kinds of files}
  \label{sl:sourcebinary}
  In programming you have two kinds of files:
  \begin{itemize}
  \item \emph{source files}\index{file!source}, which are understandable
    to you, and which you create with an editor such as \n{vi} or
    \n{emacs}; and
  \item \emph{binary files}\index{file!binary}, which are understandable
    to the computer, and unreadable to you.
  \end{itemize}
  Your source file(s) is/are translated to binary by a
  \indexterm{compiler}.
\end{block}

Let's say that
\begin{itemize}
\item you have a source code file \n{myprogram.cxx};
\item and you want an executable file called \n{myprogram},
\item and your compiler is \indextermtt{g++}, the C++ compiler of the
  \indexterm{GNU} project. (If you have the Intel compilers, you will
  use \indexterm{icpc} instead.)
\end{itemize}
To compile your program, you then type
\begin{verbatim}
g++ -o myprogram myprogram.cxx
\end{verbatim}
\begin{tacc}
  On TACC machines, use the Intel compiler:
\begin{verbatim}
  icpc -o myprogram myprogram.cxx
\end{verbatim}
\end{tacc}

which you can verbalize as `invoke the \n{g++} (or \n{icpc}) compiler,
with output \n{myprogram}, on \n{myprogram.cxx}'.

Let's do an example.

\begin{exercise}{The edit-compile-run cycle}
\label{ex:compile-cycle}
  Make a file \n{zero.cc} with the following lines:
  %
  \verbatimsnippet{nullprogc}
  %
  and compile it. Intel compiler:
\begin{verbatim}
icpc -o zeroprogram zero.cc
\end{verbatim}
\begin{itemize}
\item \texttt{icpc} : compiler. Alternative Gnu: use \texttt{g++} instead of \texttt{icpc}.
\item \texttt{-o programname} : output into a binary name of your choosing
\item \texttt{something.cc} : your source file.
\end{itemize}

Run this program (it gives no output):
\begin{verbatim}
./zeroprogram
\end{verbatim}
\end{exercise}

In the above program:
\begin{enumerate}
\item The first three lines are magic, for now. Always include them.
\item The \n{main} line indicates where the program starts; between
  its opening and closing brace will be the
  \indextermbus{program}{statements}.
\item The \n{return} statement indicates successful completion of your program.
\end{enumerate}
As you may have guessed, this program produces absolutely no output
when you run it.

\begin{exercise}{Your first useful program}
  \label{ex:sayhello}
Add this line:
%
\verbatimsnippet{helloc}
%
(copying from the pdf file is dangerous! please type it yourself)

Compile and run again.

  (Did you indent the `hello world' line? Did your editor help you with
  the indentation?)

\end{exercise}

%\snippetwithoutput{helloc}{basic}{hello}


\begin{block}{File names}
  \label{sl:file-ext}
  File names can have extensions: the part after the dot.
  \begin{itemize}
  \item \n{program.cxx} or \n{program.cc} are typical extensions for
    C++ sources.
  \item \n{program.cpp} is also used, but there is a
    possible confusion with `C~PreProcessor'.
  \item Using \n{program} without extension usually indicates an \indexterm{executable}.
  \end{itemize}
\end{block}

\begin{exercise}{Quick review}
  \label{q:compiler}
  True or false?
  \begin{enumerate}
  \item The programmer only writes source files, no binaries.
  \item The computer only executes binary files, no human-readable files.
  \end{enumerate}
\end{exercise}

\Level 1 {A quick word about unix commands}

The compile line
\begin{verbatim}
g++ -o myprogram myprogram.cxx
\end{verbatim}
can be thought of as consisting of three parts:
\begin{itemize}
\item The command \n{g++} that starts the line and determines what is
  going to happen;
\item The argument \n{myprogram.cxx} that ends the line is the main
  thing that the command works on; and
\item The option/value pair \n{-o myprogram}. Most Unix commands have
  various options that are, as the name indicates, optional. For
  instance you can tell the compiler to try very hard to make a fast program:
\begin{verbatim}
g++ -O3 -o myprogram myprogram.cxx
\end{verbatim}
  Options can appear in any order, so this last command is equivalent to
\begin{verbatim}
g++ -o myprogram -O3 myprogram.cxx
\end{verbatim}
\end{itemize}
Be careful not to mix up argument and option. If you type
\begin{verbatim}
g++ -o myprogram.cxx myprogram
\end{verbatim}
then Unix will reason: `\n{myprogram.cxx} is the output, so if that
file already exists (which, yes, it does) let's just empty it before
we do anything else'. And you have just lost your program.
Good thing that editors like
\indexterm{emacs} keep a backup copy of your file.

\Level 1 {C++ is a moving target}

The C++ language has gone through a number of standards.
\begin{itemize}
\item \emph{C++98}\index{C++!C++98} is used in many codes, and many
  textbooks and internet tutorials have been written about
  it. However, it contains many mechanisms and constructs that have
  been replaced by more elegant variants. Where these exist, the older
  variants should not be used unless there is an overwhelming need.
  However, for many compilers this is the default.
\item \emph{C++03}\index{C++!C++03} is a minor amendment of the 98 standard.
\item \emph{C++11}\index{C++!C++11} is a major overhaul of the
  standard, introducing many simplifications and additions. 
\item \emph{C++14}\index{C++!C++14} is a minor refinement of C++11.
  This book is completely based on this standard. There may be
  occasional remarks about features that are new to C++11, but many
  times they go  unremarked.

  You can tell your compiler to use this standard:
\begin{verbatim}
icpc -std=c++14 [other options]
\end{verbatim}
but to save yourself a lot of typing, you can define
\begin{verbatim}
alias icpc='icpc -std=c++14'
\end{verbatim}
in your shell startup files.
\begin{tacc}
On the class \n{isp} machine this alias has been defined by default.
\end{tacc}
\item \emph{C++17}\index{C++!C++17} adds yet more goodness to
  C++. This book will use 17-specific features only sporadically.
\item \emph{C++20/23/\ldots}\index{C++!C++20}: the C++ standars
  committee has committed itself to releasing a new standard every
  three years. Many features of these new standards are only for
  advanced use or in very large scale projects.
\end{itemize}

\begin{slide}{C++ versions}
  \label{sl:cpp-version}
  \begin{itemize}
  \item
    The compiler by default uses \n{C++98}. 
  \item This course explains \n{C++14}. You need tell your compiler
    about this.
  \item On \n{isp.tacc.utexas.edu} `icpc' uses this by default.
  \item On your own machine you need to do
\begin{verbatim}
  icpc -std=c++14 [other options]
\end{verbatim}
or
\begin{verbatim}
  alias icpc='icpc -std=c++14'
\end{verbatim}
  \end{itemize}
\end{slide}

\Level 0 {Statements}
\label{sec:statements}

Each programming language has its own (very precise!) rules for what
can go in a source file. Globally we can say that a program contains
instructions for the computer to execute, and these instructions take
the form of a bunch of `statements'. Here are some of the rules on
statements; you will learn them in more detail as you go through this
book.

\begin{block}{Program statements}
  \label{sl:cstatement}
  \begin{itemize}
  \item
    A program contains statements, each terminated by a semicolon.
  \item `Curly braces' can enclose multiple statements.
  \item A statement can correspond to some action when the program is
    executed.
  \item Some statements are definitions, of data or of possible actions.
  \item Comments are `Note to self', short:
\begin{lstlisting}
cout << "Hello world" << endl; // say hi!
\end{lstlisting}
and arbitrary:
\begin{lstlisting}
cout << /* we are now going
           to say hello
         */ "Hello!" << /* with newline: */ endl;
\end{lstlisting}
  \end{itemize}
\end{block}

\begin{exercise}
  \label{ex:hello-line}
  Take the `hello world' program you wrote above, and duplicate the
  hello-line. Compile and run.

  Does it make a difference whether you have the two hellos on the
  same line or on different lines?

  Experiment with other changes to the layout of your source. Find at
  least one change that leads to a compiler error.
\end{exercise}

\begin{block}{Errors}
  \label{sl:program-errors}
  There are two types of errors that your program can have:
  \begin{enumerate}
  \item \emph{Syntax}\index{error!syntax} or
    \emph{compile-time}\index{error!compile-time} errors: these arise
    if what you write is not according to the language specification.
    The compiler catches these errors, and it refuses to produce a
    \indextermsub{binary}{file}.
  \item \emph{Run-time}\index{error!run-time} errors: these arise if
    your code is syntactically correct, and the compiler has produced
    an executable, but the program does not behave the way you
    intended or foresaw. Examples are divide-by-zero or indexing
    outside the bounds of an array.
  \end{enumerate}
\end{block}

\begin{block}{Fixed elements}
  \label{sl:fixedstuff}
  You see that certain parts of your program are inviolable:
  \begin{itemize}
  \item There are \indexterm{keywords} such as \n{return} or \n{cout}; you
    can not change their definition.
  \item Curly braces and parentheses need to be matched.
  \item There has to be a \n{main} keyword.
  \item The \n{iostream} and \n{std} are usually needed.
  \end{itemize}
\end{block}

\begin{exercise}
  \label{ex:cout-what}
  Experiment with the \n{cout} statement. Replace the string by a
  number or a mathematical expression. Can you guess how to print more
  than one thing, for instance:
  \begin{itemize}
  \item the string \n{One third is}, and
  \item the result of the computation~$1/3$,     
  \end{itemize}
  with the same \n{cout} statement?
\end{exercise}

\begin{block}{Return statement}
  \begin{itemize}
  \item The language standard says that \n{main} has to be of type
    \n{int}; the \indextermbus{return}{statement} returns an int.
  \item Compilers are fairly tolerant of deviations from this.
  \item Usual interpretation: returning zero means success; anything else failure;
  \item This \indextermbus{return}{code} can be detected by the
    \emph{shell}\index{shell!inspect return code}
  \end{itemize}
  \snippetwithoutput{returnone}{basic}{return}
\end{block}

\Level 0 {Variables}
\label{sec:variables}

A program could not do much without storing data: input data,
temporary data for intermediate results, and final results.
Data is stored in \emph{variables}\index{variable},  which have
\begin{itemize}
\item a name, so that you can refer to them,
\item a \indexterm{datatype}, and
\item a value.
\end{itemize}
Think of a variable as a labeled placed in memory.
\begin{itemize}
\item The variable is defined in a
  \indextermbus{variable}{declaration},
\item which can include an \indextermsub{variable}{initialization}.
\item After a variable is defined, and given a value, it can be used,
\item or given a (new) value in a \indextermbus{variable}{assignment}.
\end{itemize}

\begin{slide}{What's a variable?}
  \label{sl:declaration}
  Programs usually contain data, which is stored in a
  \indextermdef{variable}. A~variable has
  \begin{itemize}
  \item a \indexterm{datatype},
  \item a name, and
  \item a value.
  \end{itemize}
  These are defined in a \indextermbus{variable}{declaration} and/or
  \indextermbus{variable}{assignment}.
\end{slide}

\begin{block}{Typical variable lifetime}
  \label{sl:varlife}
\begin{lstlisting}
int i,j; // declaration
i = 5; // set a value
i = 6; // set a new value
j = i+1; // use the value of i
i = 8; // change the value of i
       // but this doesn't affect j:
       // it is still 7.
\end{lstlisting}
\end{block}

\Level 1 {Variable declarations}

A variable is defined once
in a \indextermbus{variable}{declaration},
but it can be given a (new) value multiple
times. It is not an error to use a variable that has not been given a
value, but it may lead to strange behaviour at runtime, since the
variable may contain random memory contents.

\begin{block}{Variable names}
  \label{sl:varname}
  \begin{itemize}
  \item
    A variable name has to start with a letter;
  \item a name can contains letters and  digits, but not most
    special characters, except for the underscore.
  \item For letters it matters
    whether you use upper or lowercase: the language is \indexterm{case sensitive}.
  \item Words such as \n{main} or \n{return} are \indexterm{reserved words}.
  \item Usually \n{i} and \n{j} are not the best variable names: use
    \n{row} and \n{column} instead.
  \end{itemize}
\end{block}

\begin{block}{Declaration}
  \label{sl:declare-example}
  There are a couple of ways to make the connection between a name and a
  type. Here is a simple
  \indextermbusdef{variable}{declaration}, which establishes the name
  and the type:
\begin{lstlisting}
int n;
float x;
int n1,n2;
double re_part,im_part;
\end{lstlisting}
\end{block}

\begin{block}{Where do declarations go?}
  \label{sl:declwhere}
  Declarations can go pretty much anywhere in your program, but they need
  to come before the first use of the variable.

  Note: it is legal to define a variable before the main program
  but that's not a good idea. Please only declare \emph{inside} main
  (or inside a function et cetera).
\end{block}

\begin{exercise}{Quick review}
  \label{q:varnames}
  Which of the following are legal variable names?
  \begin{enumerate}
  \item \n{mainprogram} \item \n{main} \item \n{Main}
  \item \n{1forall} \item \n{one4all} \item \n{one_for_all} \item \n{onefor\char`\{all\char`\}}.
  \end{enumerate}
\end{exercise}

\Level 1 {Initialization}

It is a possible to give a variable a value right when it's
created. This is known as
\emph{initialization}\index{variable!initialization} and it's
different from creating the variable and later assigning to it
(section~\ref{c:assign}).

\begin{block}{Initialization syntax}
  \label{sl:init-var}
  There are two ways of initializing a variable
  \begin{lstlisting}
    int i = 5;
    int j{6};
  \end{lstlisting}
  Note that writing 
  \begin{lstlisting}
    int i;
    i = 7;
  \end{lstlisting}
  is not an initialization: it's a declaration followed by an
  assignment.

  If you declare a variable but not initialize, you can not count on
  its value being anything, in particular not zero. Initialization is
  often omitted for performance reasons.
\end{block}

\Level 1 {Datatypes}
\label{sec:ctypes}

\begin{block}{Datatypes}
  \label{sl:datatypes}
  Variables come in different types;
  \begin{itemize}
  \item We call a variable of type
    \n{int,float,double} a \indextermsub{numerical}{variable}.
  \item \emph{Complex numbers}\index{complex numbers} will be
    discussed later.
  \item 
    For characters: \n{char}. Strings are complicated; see later.
  \item Truth values: \n{bool}
  \item 
    You can make your own types. Later.
  \end{itemize}
\end{block}

For complex numbers see section~\ref{sec:stl-complex}.
For strings see chapter~\ref{ch:string}.

At some point you may start to wonder precisely what the range of
integers or real numbers is that is storedin an \n{int} or \n{float}
variable. This is addressed in section~\ref{sec:limits}.

\Level 1 {Assignments}
\label{c:assign}

Setting a variable
\begin{lstlisting}
i = 5;
\end{lstlisting}
means storing a value in the memory location. It is
not the same as defining a mathematical equality
\[ \hbox{let $i=5$}. \]

\begin{block}{Assignment}
  \label{sl:assign1}
  Once you have declared a variable, you need to establish a value. This is done in an
  \indextermdef{assignment} statement. After the above declarations, the
  following are legitimate assignments:
\begin{lstlisting}
n = 3;
x = 1.5;
n1 = 7; n2 = n1 * 3;
\end{lstlisting}
Variable of the left-hand side gets value of the right-hand side.

You see that you can assign both a simple value or an
\indexterm{expression}.
\end{block}

\begin{block}{Assignments}
  \label{sl:assign2}
  A variable can be given a value more than once. The following
  sequence of statements is a legitimate part of a program:
\begin{lstlisting}
int n;
n = 3;
n = 2*n + 5;
n = 3*n + 7;
\end{lstlisting}
These are not math equations: variable on the lhs gets the value of
the rhs.
\end{block}

\begin{block}{Special forms}
  \label{sl:special-assign}
  Update:
\begin{lstlisting}
  x = x+2; y = y/3;
  // can be written as
  x += 2; y /= 3;
\end{lstlisting}
Integer add/subtract one:
\begin{lstlisting}
  i++; j--;  /* same as: */ i=i+1; j=j-1;
\end{lstlisting}
\end{block}

\begin{exercise}
  \label{q:assign}
  Which of the following are legal? If they are, what is their meaning?
  \begin{enumerate}
  \item \n{n = n;}
  \item \n{n = 2n;}
  \item \n{n = n2;}
  \item \n{n = 2*k;}
  \item \n{n/2 = k;}
  \item \n{n /= k;}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  \label{ex:print-variables}
  Write a program that has several variables. Assign values either in
  an initialization or in an assignment. Print out the values.
\end{exercise}

\begin{exercise}{Quick review}
  \label{q:initvar}
\begin{lstlisting}
#include <iostream>
using std::cout;
using std::endl;
int main() {
  int i;
  int j = i+1;
  cout << j << endl;
  return 0;
}
\end{lstlisting}
What happens?
\begin{enumerate}
\item Compiler error
\item Output: \n{1}
\item Output is undefined
\item Error message during running the program.
\end{enumerate}
\end{exercise}

\Level 1 {Floating point variables}

Mathematically, integers are a special case of real numbers.
In a computer, integers are stored very differently from
\indextermdef{floating point} numbers.
\begin{itemize}
\item Within a certain range, roughly
  $-2\cdot 10^9,\ldots,2\cdot 10^9$,
  all integer values can be represented.
\item On the other hand, not all real numbers have a floating point
  representation. For instance, since computer numbers are binary,
  $1/2$~is representable but $1/3$~is not.
\item You can assign variables of one type to another, but this may
  lead to truncation (assigning a floating point number to an integer)
  or unexpected bits (assigning a single precision floating point
  number do a double precision).
\end{itemize}

Floating points numbers do not behave like mathematical numbers. 

\begin{block}{Warning: floating point arithmetic}
  \label{sl:float-arith}
  Floating point arithmetic is full of pitfalls.
  \begin{itemize}
  \item Don't count on \n{3*(1./3)} being exactly~1.
  \item Not even associative.
  \end{itemize}
  (See Eijkhout, Introduction to High Performance Computing, chapter~3.)
\end{block}

The following exercise illustrates another point about computer numbers.

\begin{exercise}
  \label{ex:macheps}
  Define 
\begin{lstlisting}
float one = 1.;
\end{lstlisting}
and
  \begin{enumerate}
  \item Read a \lstinline{float eps},
  \item Make a new variable that has the value \lstinline{one+eps}. Print
    this.
  \item Make another variable that is the previous one minus
    \lstinline{one}. Print the result again.
  \item Test your program with a range of inputs. Are there ones that
    surprise you?  
  \end{enumerate}

\end{exercise}

Complex numbers exist, see section~\ref{sec:stl-complex}.

\Level 1 {Number values and undefined values}
\label{sec:naninf}

A computer allocates a fixed amount of space for integers and floating
point numbers, typically 4 or 8 bytes. That means that not all numbers
are representable.
\begin{itemize}
\item Using 4 bytes, that is 32 bits, we can represent $2^{32}$
  integers. Typically this is the range $-2^{31}\ldots 0 \ldots
  2^{31}-1$.
\item Floating point numbers are representated by a sign bit, an
  exponent, and a number of significant digits.
  For 4-byte numbers, the number of significant (decimal) digits is
  around~6; for 8-byte numbers it is around 15.
\end{itemize}

If you compute a number that `fall in between the gaps' of the
representable numbers, it gets truncated or rounded. The effects of
this on your computation constitute its own field of numerical
mathematics, called \indexterm{roundoff error analysis}.

If a number goes outside the bounds of what is representable, it
becomes either:
\begin{itemize}
\item \indextermtt{Inf}: infinity. This happens if you add or multiply
  enough large numbers together. There is of course also a value
  \n{-}\indextermtt{Inf}. Or:
\item \indextermtt{NaN}: not a number. This happens if you subtract
  one \lstinline{Inf} from another, or do things such as taking the
  root of a negative number.
\end{itemize}
Your program will not be interrupted if a \lstinline{NaN} or \lstinline{Inf} is
generated: the computation will merrily (and at full speed) progress
with these numbers. See section~\ref{sec:limits} for detection of such quantities.

Some people advocate filling uninitialized memory with such illegal
values, to make it recognizable as such.

\Level 1 {Boolean values}

\begin{block}{Truth values}
  \label{sl:bool-var}
  So far you have seen integer and real variables. There are also
  \indextermsub{boolean}{values} which represent truth values. There are
  only two values: \indextermtt{true} and \indextermtt{false}.
\begin{lstlisting}
bool found{false};
found = true;
\end{lstlisting}
\end{block}

\Level 1 {Strings}

Strings, that is, strings of characters, are not a C++ built-in
datatype. Thus, they take some extra setup to use.
See chapter~\ref{ch:string} for a full discussion.
For now, if you
want to use strings:

\begin{block}{Quick intro to strings}
  \label{sl:quick-string}
  \begin{itemize}
  \item Add the following at the top of your file:
\begin{lstlisting}
#include <string>
using std::string;
\end{lstlisting}
\item Declare string variables as
\begin{lstlisting}
string name;
\end{lstlisting}
\item And you can now \lstinline{cin} and \lstinline{cout} them.
  \end{itemize}
\end{block}

\begin{exercise}
  \label{ex:ask-for-name}
  Write a program that asks for the user's first name, and prints
  something like \n{Hello, Susan!} in response.

  What happens if you enter first and last name?
\end{exercise}

\Level 0 {Input/Output, or I/O as we say}
\label{sec:io}

A program typically produces output. For now we will only display
output on the screen, but output to file is possible too.  Regarding
input, sometimes a program has all information for its computations,
but it is also possible to base the computation on user input.

\begin{block}{Terminal output}
  \label{sl:cout}
You have already seen \indextermtt{cout}:
\begin{lstlisting}
float x = 5;
cout << "Here is the root: " << sqrt(x) << endl;
\end{lstlisting}
\end{block}

\begin{block}{Terminal input}
  \label{sl:cin}
  There is also a \lstinline{cin}, which serves to take user input and
  put it in a numerical variable.
\begin{lstlisting}
// add at the top of your program:
using std::cin;

// then in your main:
int i;
cin >> i;
\end{lstlisting}
There is also \lstinline{getline}, which is more general.
\end{block}

\begin{exercise}
  \label{ex:cin-cout3np1}
  Write a program that :
  \begin{itemize}
  \item displays the message \n{Type a number},
  \item accepts an integer number from you (use~\lstinline{cin}),
  \item makes another variable that is three times that integer plus one,
  \item and then prints out the second variable.
  \end{itemize}
\end{exercise}

For more I/O, see chapter~\ref{ch:io}.

\Level 0 {Expressions}
\label{sec:expr}

The most basic step in computing is to form expressions such as sums,
products, logical conjuctions, string appending. Let's start with
constants.

\Level 1 {Constants}

\begin{block}{Integer constants}
  \label{sl:intvals}
  Integers are normally  written in decimal, and stored in 32 bits.
  If you need something else:
\begin{lstlisting}
int d = 42;
int o = 052; // start with zero
int x = 0x2a;
int X = 0X2A;
int b = 0b101010; // C++14
long ell = 42L;
\end{lstlisting}
\end{block}

\begin{block}{Floating point constants}
  \label{sl:float-vars}
  \begin{itemize}
  \item Default: \lstinline{double}
  \item Float: \lstinline{3.14f} or \lstinline{3.14F}
  \item Long double: \lstinline{1.22l} or \n{1.22L}.
  \end{itemize}
  This prevents numerical accidents: 
\begin{lstlisting}
  double x = 3.;
\end{lstlisting}
  converts float to double, maybe introducing random bits.
\end{block}

\Level 1 {Numerical expressions}

Expressions in
programming languages for the most part look the way you would expect
them to.
\begin{itemize}
\item Mathematical operators: \n{+ - /} and \n{*}~for multiplication.
\item C++ does not have a power operator (Fortran does).
\item Integer modulus:~\n{5\char`\%2}
\item You can use parentheses: \n{5*(x+y)}. Use parentheses if you're
  not sure about the precedence rules for operators.
\item `Power' and various mathematical functions are realized through
  library calls.
\end{itemize}

\begin{block}{Math library calls}
  \label{sl:cmath}
  Math function in \indextermtt{cmath}:
\begin{lstlisting}
#include <cmath>
.....
x = pow(3,.5);
\end{lstlisting}
For squaring, usually better to write \n{x*x} than \n{pow(x,2)}.
\end{block}

\begin{slide}{Arithmetic expressions}
  \label{sl:arith-expr}
  \begin{itemize}
  \item
    Expression looks pretty much like in math.\\
    With integers: \n{2+3}\\
    with reals: \n{3.2/7}
  \item Use parentheses to group \n{25.1*(37+42/3.)}
  \item Careful with types.
  \item There is no `power' operator: library functions. Needs a line
\begin{lstlisting}
#include <cmath>
\end{lstlisting}
  \item Modulus: \n{\char`\%}
  \end{itemize}
\end{slide}

\Level 1 {Truth values}

In addition to numerical types, there are truth values,
\indextermtt{true} and \indextermtt{false}, with all the usual logical
operators defined on them.

\begin{block}{Boolean expressions}
  \label{sl:bool-expr}
  \begin{itemize}
  \item Testing: \n{== != < > <= >=}
  \item Not, and, or:   \n{! && ||}
  \item Shortcut operators:
\begin{lstlisting}
  if ( x>=0 && sqrt(x)<5 ) {}
\end{lstlisting}
  \end{itemize}
\end{block}

Logical expressions in C++ are evaluated using
\emph{shortcut operators}\index{operator!shortcut}: you can write
\begin{lstlisting}
x>=0 && sqrt(x)<2
\end{lstlisting}
If \n{x}~is negative, the second part will never be evaluated because
the `and' conjunction can already be concluded to be false.
Similarly, `or' conjunctions will only be evaluated until the first
true clause.

The `true' and `false' constants could strictly speaking be stored in
a single bit. C++~does not do that, but there are bit
operators that you can apply to, for instance, all the bits in an integer.

\begin{block}{Bit operators}
  \label{sl:bit-oper}
 Bitwise: \n{& | ^}
\end{block}

\Level 1 {Type conversions}

Since a variable has one type, and will always be of that type,
you may wonder what happens with
\begin{lstlisting}
float x = 1.5;
int i;
i = x;
\end{lstlisting}
or 
\begin{lstlisting}
int i = 6;
float x;
x = i;
\end{lstlisting}

\begin{itemize}
\item Assigning a floating point value to an integer truncates the
  latter.
\item Assigning an integer to a floating point variable fills it up
  with zeros after the decimal point.
\end{itemize}

\begin{exercise}
  \label{ex:float-convert}
  \begin{itemize}
  \item What happens when you assign a positive floating
    point value to an integer variable?
  \item What happens when you assign a negative floating
    point value to an integer variable?
  \item What happens when you assign a \n{float} to a \n{double}? 
    Try various numbers for the original float. Can you explain the
    result?
    (Hint: think about the conversion between binary and decimal.)
  \end{itemize}
\end{exercise}

The rules for type conversion in expressions are not entirely
logical. Consider
\begin{lstlisting}
float x; int i=5,j=2;
x = i/j;
\end{lstlisting}
This will give~\n{2} and not~\n{2.5}, because \n{i/j} is an integer
expression and is therefore completely evaluated as such, giving~\n{2}
after truncation. The fact
that it is ultimately assigned to a floating point variable does not
cause it to be evaluated as a computation on floats.

You can force the expression to be computed in floating point numbers
by writing
\begin{lstlisting}
x = (1.*i)/j;
\end{lstlisting}
or any other mechanism that forces a conversion, without changing the
result.  Another mechanism is the \indexterm{cast}; this will be
discussed in section~\ref{sec:cast}.

\begin{slide}{Conversion and casting}
  \label{sl:convert-cast}
  Real to integer: round down:
\begin{lstlisting}
  double x,y; x = .... ; y = .... ;
  int i; i =  x+y:
\end{lstlisting}
Dangerous:
\begin{lstlisting}
  int i,j; i = ... ; j = ... ; 
  double x ; x = 1+i/j;
\end{lstlisting}
The fraction is executed as integer division.\\
For floating point result do:
\begin{lstlisting}
(double)i/j /* or */ (1.*i)/j
\end{lstlisting}
\end{slide}

\begin{exercise}
  \label{ex:modulus}
  Write a program that asks for two integer numbers \n{n1,n2}.
  \begin{itemize}
  \item Assign the integer ratio $n_1/n_2$ to an integer variable.
  \item Can you use this variable to compute the modulus
    \[ n_1\mod n_2 \]
    (without using the \n{\char`\%} modulus operator!)\\
    Print out the value you get.
  \item Also print out the result from using the modulus
    operator:\n{\char`\%}.
  \item Investigate the behaviour of your program for negative
    inputs. Do you get what you were expecting?
  \end{itemize}
\end{exercise}

\begin{exercise}
  \label{ex:C2F}
  Write two programs, one that reads a temperature in Centigrade and
  converts to Fahrenheit, and one that does the opposite conversion.
  \[ C = (F-32)\cdot 5/9,\qquad F = 9/5\,C+32 \]
  Check your program for the freezing and boiling point of water.\\
  (Do you know the temperature where Celsius and Fahrenheit are the
  same?)
  
  Can you use Unix pipes to make one accept the output of the other?
\end{exercise}

\begin{exercise}{Quick review}
  \label{q:vartypes}
  True of false?
  \begin{enumerate}
  \item Within a certain range, all integers are available as values of an
    integer variable.
  \item Within a certain range, all real numbers are available as values of a
    float variable.
  \item \verb-5(7+2)- is equivalent to~\n{45}.
  \item \verb+1--1+ is equivalent to zero.
  \item \verb-int i = 2./3.;- The variable \n{i} is~1.
  \item \verb-float x = 2/3;- The variable \n{x} is approximately~\n{0.6667}.
  \end{enumerate}
\end{exercise}

\Level 0 {Library functions}

Some functions, such as \indexterm{abs} can be included through \indextermtt{cmath}:
\begin{lstlisting}
#include <cmath>
using std::abs;
\end{lstlisting}
Others, such as \indexterm{max}, are in the less common \indextermtt{algorithm}:
\begin{lstlisting}
#include <algorithm>
using std::max;
\end{lstlisting}

\Level 0 {Review questions}

\begin{exercise}
  \label{ex:cpp-mod}
What is the output of:
\begin{lstlisting}
int m=32, n=17;
cout << n%m << endl;
\end{lstlisting}
\end{exercise}

\begin{exercise}
  \label{ex:cpp-cube}
  Given
\begin{lstlisting}
int n;
\end{lstlisting}
give an expression that
uses elementary mathematical operators to compute n-cubed: $n^3$.
Do you get the correct result for all~$n$? Explain.

How many elementary operations does the computer perform to compute
this result?

Can you now compute $n^6$, minimizing the number of operations the
computer performs?
\end{exercise}
