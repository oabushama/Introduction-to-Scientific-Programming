% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the course
%%%% Introduction to Scientific Programming in C++11/Fortran2003
%%%% copyright 2017-9 Victor Eijkhout eijkhout@tacc.utexas.edu
%%%%
%%%% if.tex : conditionals
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A program consisting of just a list of assignment and expressions
would not be terribly versatile. At least you want to be able to say
`if $x>0$, do one computation, otherwise compute something else', or `until some
test is true, iterate the following computations'. The mechanism for
testing and choosing an action accordingly is called a
\indexterm{conditional}.

\Level 0 {Conditionals}
\label{sec:if}

Here are some forms a conditional can take.

Single statement
\begin{lstlisting}
if (x<0)
  x = -x;
\end{lstlisting}
Single statement and alternative:
\begin{lstlisting}
if (x>=0)
  x = 1;
else
  x = -1;
\end{lstlisting}
Multiple statements:
\begin{lstlisting}
if (x<0) {
  x = 2*x; y = y/2;
} else {
  x = 3*x; y = y/3;
}
\end{lstlisting}
Chaining conditionals (where the dots stand for omitted code):
\begin{lstlisting}
if (x>0) {
  ....
} else if (x<0) {
  ....
} else {
  ....
}
\end{lstlisting}
Nested conditionals:
\begin{lstlisting}
if (x>0) {
  if (y>0) {
    ....
  } else {
    ....
  }
} else {
  ....
}
\end{lstlisting}
\begin{itemize}
\item
  In that last example the outer curly brackets in the true branch are
  optional. But it's safer to use them anyway.
\item When you start nesting constructs, use indentation to make it
  clear which line is at which level. A~good editor helps you with that.
\end{itemize}

\begin{slide}{If-then-else}
  \label{sl:ifthenelse}
  A \indextermdef{conditional} is a test: `if something is true, then do
  this, otherwise maybe do something else'. The C++ syntax is
\begin{lstlisting}
if ( something ) {
  // do something;
} else {
  // do otherwise;
}
\end{lstlisting}
\begin{itemize}
\item The `else' part is optional
\item You can leave out braces in case of single statement.
\end{itemize}
\end{slide}

\begin{slide}{Complicated conditionals}
  \label{sl:elseif}
  Chain:
\begin{lstlisting}
if ( /* some test */ ) {
  ...
} else if ( /* other test */ ) {
  ...
}
\end{lstlisting}
Nest:
\begin{lstlisting}
if ( /* some test */ ) {
  if ( /* other test */ ) {
    ...
  } else {
    ...
  }
}
\end{lstlisting}
\end{slide}

\begin{exercise}
  \label{ex:if-scope-ab}
  For what values of $x$ will the left code print~`\n{b}'?\\
  For what values of $x$ will the right code print~`\n{b}'?
  \begin{multicols}{2}
\begin{lstlisting}
float x = /* something */
if ( x > 1 ) {
   cout << "a" << endl;
   if ( x > 2 )
    cout << "b" << endl;
}
\end{lstlisting}
\columnbreak
\begin{lstlisting}
float x = /* something */
if ( x > 1 ) {
   cout << "a" << endl;
} else if ( x > 2 ) {
    cout << "b" << endl;
}
\end{lstlisting}
  \end{multicols}
\end{exercise}

\Level 0 {Operators}

You have already seen arithmetic expressions; now we need to look at
logical expressions: just what can be tested in a conditional. 
Here is a fragment of language grammar that spells out what is
legal. You see that most of the rules are recursive, but there is an
important exception.

\begin{block}{What are logical expressions?}
  \label{sl:logical-syntax}
\begin{verbatim}
logical_expression :: 
  comparison_expression
  | NOT comparison_expression
  | logical_expression CONJUNCTION comparison_expression
comparison_expression :: 
  numerical_expression COMPARE numerical_expression
numerical_expression :: 
  quantity
  | numerical_expression OPERATOR quantity
quantity :: number | variable
\end{verbatim}
\end{block}

\begin{block}{Comparison and logical operators}
  \label{sl:operators}
  \begin{tabular}{|l|l|l|}
    \hline
    Operator&meaning&example\\ \hline
    \texttt{==}&equals&\texttt{x==y-1}\\
    \texttt{!=}&not equals&\texttt{x*x!=5}\\
    \texttt{>}&greater&\texttt{y>x-1}\\
    \texttt{>=}&greater or equal&\texttt{sqrt(y)>=7}\\
    \texttt{<},\texttt{<=}&less, less equal&\texttt{}\\
    \n{&&},\n{||}&and, or&\n{x<1 && x>0}\\
    \n{and},\n{or}&&\n{x<1 and x>0}\\
    \texttt{!}&not&\n{!( x>1 && x<2 )}\\
    \texttt{not}&&\n{not ( x>1 and x<2 )}\\
    \hline
  \end{tabular}

  \emph{Precedence}\index{precedence} rules are common sense. When in
  doubt, use parentheses.
\end{block}

\begin{exercise}
  \label{ex:oddeven}
  Read in an integer. If it is even, print `even', otherwise print
  'odd':
\begin{lstlisting}
if ( /* your test here */ ) 
  cout << "even" << endl;
else
  cout << "odd" << endl;
\end{lstlisting}
Then, rewrite your test so that the true branch corresponds to the odd case?
\end{exercise}

\begin{exercise}
  \label{ex:fizzbuzz}
  Read in an integer. If it's a multiple of three print `Fizz!';
  if it's a multiple of five print `Buzz'!. It it is 
  a multiple of both three and five print `Fizzbuzz!'. Otherwise
  print nothing. (Note: your program should display at most one output.)
\end{exercise}

\begin{review}
  \label{q:if}
  True or false?
  \begin{itemize}
  \item The tests \lstinline$if (i>0)$ and \lstinline$if (0<i)$ are equivalent.
  \item The test
\begin{lstlisting}
if (i<0 && i>1) 
  cout << "foo"
\end{lstlisting}
prints \n{foo} if
    $i<0$ and also if $i>1$.
  \item The test 
\begin{lstlisting}
if (0<i<1)
  cout << "foo"
\end{lstlisting}
prints \n{foo} if $i$ is
    between zero and one.
  \end{itemize}
  Any comments on the following?
\begin{lstlisting}
bool x;
// ... code with x ...
if ( x == true )
  // do something
\end{lstlisting}
\end{review}

\Level 0 {Switch statement}

If you have a number of cases corresponding to specific integer
values, there is the \indextermtt{switch} statement.

\begin{block}{Switch statement example}
  \label{sl:switch}
  Cases are executed consecutively until you `break' out of the switch
  statement:
  %
  \snippetwithoutput{switchstatement}{basic}{switch}
\end{block}

\begin{exercise}
  \label{ex:switch-range}
  Suppose the variable \n{n} is a nonnegative integer. Write a
  \n{switch} statement that has the same effect as:
\begin{lstlisting}
if (n<5)
  cout << "Small" << endl;
else
  cout << "Not small" << endl;
\end{lstlisting}

\end{exercise}
\Level 0 {Scopes}

The true and false branch of a conditional can consist of a single
statement, or of a block in curly brackets. Such a block creates a
%
\emph{scope}\index{scope!in conditional branches}
%
where you can define local variables.

\begin{lstlisting}
if ( something ) {
  int i; 
  .... do something with i
}
// the variable `i' has gone away.
\end{lstlisting}

See chapter~\ref{ch:scope} for more detail.

\begin{slide}{Local variables in conditionals}
  \label{sl:if-scope}
  The curly brackets in a conditional allow you to define local variables:
\begin{lstlisting}
if ( something ) {
  int i; 
  .... do something with i
}
// the variable `i' has gone away.
\end{lstlisting}
Good practice: only define variable where needed.

Braces induce a \indexterm{scope}.
\end{slide}

